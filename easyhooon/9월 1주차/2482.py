# 색상환
import sys

si = sys.stdin.readline
MOD = 10 ** 9 + 3

# 색상환에 포함된 색의 개수
n = int(si())
# 색상환에서 선택할 색의 개수
k = int(si())

# n 색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 k개의 색을 고를 수 있는 경우의 수
# 1 2 3 4
# 1 3
# 2 4
# 2 (원형이기 때문에 1, 4 이렇게 고르면 1, 4 가 인접
# dp[i][j]:= i 색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 j개의 색을 고를 수 있는 경우의 수
# j는 i // 2 까지
# rgb 거리 문제랑 비슷
# 첫번째 칸 부터 채우느냐(마지막 칸 채울 수 없음), 두번째 칸 부터 채우느냐(마지막 칸 채울 수 있음)
# 둘다 안채워도 되긴하네

if n // 2 < k:
    print(0)
    exit(0)

dp = [[0] * (k + 1) for _ in range(n + 1)]

# 기저 조건
for i in range(n + 1):
    # 하나도 안채우는 경우
    dp[i][0] = 1
    # i 개의 칸 중에 1개만 택해서 채울 경우
    dp[i][1] = i

# 점화식 채우기
for i in range(2, n + 1):
    for j in range(2, k + 1):
        # dp[i][j] = (dp[i - 1][j] + dp[i - 2][j - 1]) % MOD
        # i 번째 칸을 선택 하지 않을 경우 -> 이전 칸의 경우의 수 그대로
        dp[i][j] += dp[i - 1][j] % MOD
        # i 번째 칸을 선택할 경우 -> i - 1 번째 칸 선택 불가, i - 2 번째 칸 까지, j - 1 개를 선택
        dp[i][j] += dp[i - 2][j - 1] % MOD

# 마지막 칸을 선택하지 않는 경우와 선택하는 경우
# 마지막 칸을 선택하면 사용할 수 있는 칸은 2번째 ~ n - 2번째
# 이는 1번째 부터 n -3 번째까지 사용한 것과 같음
print((dp[n - 1][k] + dp[n - 3][k - 1]) % MOD)



