---
platform: BOJ
link: https://www.acmicpc.net/problem/15961
tags:
  - two_pointer
  - sliding_window
difficulty: g4
정답 참조: true
is_study: true
week-date:
  - 10월
  - 2주차
---

#  \[`=this.file.frontmatter.platform`\]`=this.file.name`


### 풀이
#### 아이디어
우선 코드부터 첨부한다.
```python
import sys
input = sys.stdin.readline

plate, kinda, series, cupon = map(int, input().split())
lane = list(int(input()) for _ in range(plate))*2
# res = [[0, 0] for _ in range(plate+1)]  # 가짓수, 종류수
res = [0]*(plate+1)

sp, ep = 0, series

while sp <= plate:
    window, kind = lane[sp:ep], len(set(lane[sp:ep]))
    # print(window, kind)
    # res[sp][0], res[sp][1] = kind, kind
    res[sp] = kind
    if cupon not in window:
        # res[sp][0] += 1
        res[sp] += 1
        
    sp, ep = sp+1, ep+1

# print(sorted(res, key = lambda x:(-x[0], -x[1])))
print(max(res))
```
아이디어는 연속으로 먹은 초밥을 슬라이싱하고, 최대한 많은 종류의 초밥을 먹어야하므로, `set`을 이용해서 중복을 제거한 개수를 저장해주었다.

지금 와서 보니까 문제를 잘못읽은 부분이 있는데, 만약 쿠폰으로 받은 초밥번호가 내가 연속으로 먹는 초밥 시리즈에 없다면 1개를 더해준다. 이부분은 문제에서 "초밥이 없다면 만들어준다"라는 조건을 빼고 봐서 그렇다.

이 코드는 우선 시간초과가 발생한다. 그도그럴것이 6백만 크기의 리스트 인덱싱을 반복하니까 $N \times (N-1)$정도의 연산이 반복된다. 또한 인덱싱은 인덱싱 크기만큼의 연산이 추가로 필요하므로 series를 s라고 했을때 저기에 s를 또 곱해줘야한다..


#### 코드
```python
import sys
input = sys.stdin.readline
from collections import defaultdict

N, d, k, c = map(int,input().split())
sushi = []
for _ in range(N):
    sushi.append(int(input()))
sushi.extend(sushi)

left = 0
right = 0
max_cnt = 0
eat = defaultdict(int)

eat[c] += 1

for right in range(len(sushi)):
    eat[sushi[right]] += 1

    if right >= k-1:
        max_cnt = max(max_cnt,len(eat))
        eat[sushi[left]] -= 1
        if eat[sushi[left]] == 0:
            del eat[sushi[left]]
        left += 1
        
print(max_cnt)
```
1. 나는 리스트 크기를 2배로 늘릴때 곱 연산을 이용했지만 코드에서는 `.extend()`를 사용했다.
2. `eat`이라는 변수에 값이 없는 딕셔너리 (default dict)을 생성하였고, 실제로 시뮬레이션 하듯이 먹고 빼고를 반복한다.
3. 쿠폰으로 주는 초밥은 무조건 먹으므로 c에 1을 더해준다.
4. 슬라이딩 윈도우를 적용해주는데, k 만큼은 무조건 먹고, 만약 오른쪽 포인터가 그 이상이 갔을때, 왼쪽 포인터를 옮겨주고, 해당 위치에 있는 초밥의 개수를 줄여준다
5. 만약 초밥을 줄였을때 개수가 0이라면 해당 키를 삭제시켜 개수를 업데이트해준다.


> 즉 딕셔너리가 저장하는 값은 각각의 번호의 초밥을 몇개 먹었는가? 를 저장하며, 그 종류의 개수를 세어 가장 큰 값을 정답으로 한다.

---
### 회고
슬라이딩 윈도우라는 주제를 제대로 풀어본적이 없어 아이디어를 떠올리기 쉽지 않았던 문제.